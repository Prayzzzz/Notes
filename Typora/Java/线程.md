# 线程

## 线程和进程

**进程：**是一个正在执行中的程序。

​			每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。

**线程：**是进程中一个独立的控制单元，线程控制着进程的执行。

一个进程中**至少有一个**线程。

```
java vm 启动的时候会有一个进程java.exe
该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中，
该线程称为主线程。
扩展:
jvm启动不止一个线程,还有垃圾回收机制的线程.
```

## **多线程的特性**

一个程序(程序运行时),可以分化为并行执行多个线程(多个子程序)

随机性（CPU随机执行某个线程）

### 多线程的优点

- 提高应用程序的响应.对图形化界面更有意义,可增强用户体验。
- 提高计算机系统CPU的利用率.
- 改善程序结构.将既长又复杂的进程分为多个线程,独立运行,利于理解和修改

### **创建线程的方式**

**多线程的异步**	两个线程之间交叉输出结果,没有顺序
start开启线程后线程(run)内的代码与线程外的代码并行运行,相当于两个并行程序.

两个并行程序的结果交叉混合,但单个线程的结果保持自己的顺序

#### 第一种方式	继承Thread类

1. 定义类继承Thread

2. 重写Thread中的run方法

   目的:将自定义的代码存储在run()方法中,让线程运行.

3. 创建Thread子类对象

   即创建了线程对象

4. 调用线程的start()方法(必须使用start方法开启线程)

   start方法的作用:启动线程,调用run方法。


```java
方法
run();//方法中存放的是线程要运行的代码
start();//启动线程
Thread thread0 = new day15.TestThread();//
```

####    第二种方式	实现Runnable接口(**常用**)

1. 定义类实现Runnable接口
2. 重写Runnable接口中的run方法
3. 通过Thread类建立线程对象
4. 将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法.
5. 调用Thread类的start方法开启线程并调用Runnable接口子类中的run方法.

 ```java
Runnable runnable =new TestRunnable();
Thread t = new Thread(runnable, "t-1");
//上下作用相同
Thread t = new Thread(new TestRunnable(),"t-1");//t-1是指定的线程名 
 ```

#### **继承方式和实现方式的区别**

**继承Thread**:线程代码存放Thread子类run方法中。	重写run方法
**实现Runnable**:线程代码存在接口的子类的run方法,	实现run方法

**实现的好处**

- 避免了单继承的局限.
- 多个线程可以共享同一个接口实现类的对象,**适合多个相同线程来处理同一份资源**。

#### Thread常用的方法

```java
方法
static Thread currentThread();//返回当前线程对象的引用
setName();//设置线程名
/**
 * 线程优先级,优先级高的有较大概率被执行
 * 优先级用数字1-10表示,数字越大优先级越高,缺省值为5
 */
getPriority();//返回优先级的值
setPriority(int );//设置线程的优先级
static void yield();//线程让步	暂停当前正在执行的线程,把执行机会给优先级相同的或更高的线程
join();//当前线程将被阻塞,先执行调用join这个线程的代码  
static void sleep(毫秒);//使调用该方法线程睡眠xxx毫秒
stop();//强制线程生命期结束
isAlive();//判断当前线程是否存活
```

### 线程的生命周期

#### **五种状态**

- **新建**	线程实例创建
- **就绪**    执行start()方法之后
- **运行**    run方法中的代码开始执行
- **阻塞**    run方法中的代码暂停执行
- **死亡**    
  - 自然死亡：程序执行完毕或出现异常终止
  - 强制死亡：执行stop()方法、断电、杀掉进程

### 多线程的安全问题

**出现原因**

当多条语句在操作同一个线程共享数据时,一个线程对多条语句只执行了一部分,还没有

执行完,其他线程就参与进来执行,导致共享数据的错误..

**解决方法**:同步代码块,同步方法

### synchronized同步锁

- 普通方法加同步锁，锁的是当前方法对应的对象，不是该方法，不同的对象还是用的不同的锁，不同的对象调用此方法还是存在共享资源不同步的问题

  ```java
  public synchronized void drawing(int m) {xxx}
  ```

- 静态方法加同步锁，锁的是方法，所有调用此对象都共用一个锁

  ```java
  public static synchronized void drawing2(int m) {xxx}
  ```

- 同步代码块用this锁代码块代表当前的对象.若其他方法中也存在synchronized (this)代码块使用的也是同一个同步锁

  ```java
  synchronized (this){xxx}
  ```

- 通过方法传入对象synchronized (a)代码块，小括号中传入不同的对象就是不同的锁

  ```java
  public void drawing5(int m, Acount a) {
      String name = Thread.currentThread().getName();
     	synchronized (a) {//表示通过方法传递进来的对象的代码块也被增加了同步锁 
     						//不同的对象有不同的同步锁
  ```

#### 用法

如果针对对象要加同步锁，那就加方法上

如果针对某一段代码需要加同步锁，那就直接在代码块上加同步锁

#### 同步代码块

优点:解决了多线程的安全问题

缺点:消耗计算机资源

#### 同步锁的弊端(死锁)

**概述**

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，

就形成了线程的死锁

同步中嵌套同步。

**解决方式**

- 专门的算法、原则，比如加锁顺序一致
- 尽量减少同步资源的定义，尽量避免锁未释放的场景

#### 线程间的通信

其实就是多线程在操作同一个资源,但操作的动作不同.

#### **等待唤醒机制**

```java
三个方法都属于Object类的方法,都必须在synchronized方法或synchronized代码块中才能使用，否则会出现异常
wait();//令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问
notify();//唤醒正在排队等待同步资源的线程中优先级最高者结束等待
notifyAll();//唤醒正在排队等待资源的所有线程结束等待.
都使用在同步中,因为要对持有监视器(锁)的线程操作,
所以要在同步中,因为只有同步才具有锁.
等待和唤醒的必须是同一个监视器.
```

#### **停止线程**

通过run方法结束。

#### **守护线程**

- 在启动前调用.
- 当正在运行的线程全是守护线程时,java虚拟机退出.