## 面向对象

### 面向对象和面向过程区别

面向过程	强调功能行为

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

缺点：没有面向对象易维护、易复用、易扩展

面向对象	将功能封装进对象,强调具备了功能的对象.

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
缺点：性能比面向过程低

**面向对象是基于面向过程的.**

### 面向对象

​	特征

- 封装

- 继承

- 多态

**类:**

具有同种属性的对象称为类.

对现实生活中事物的描述.描述事物就是在描述事物的属性和行为

属性对应的是类中变量,行为对应的是方法(函数).

class定义的是类

**对象:**

是类的实例化.

new定义的是对象(实体)

例子:比如“人”就是一类，其中有一些人名，比如小明、小红、小玲等等这些都是对象，类就相当于一个模具，他定义了它所包含的全体对象的公共特征和功能，对象就是类的一个实例化，小明就是人的一个实例化！我们在做程序的时候，经常要将一个变量实例化，就是这个原理！我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！”

**对象的初始化过程**

```java
Perosn p =new Person("zhang",20);
```

1. 因为new用到了Person.class，所以会jvm先找到Person.class文件并加载到方法区中。
2. 加载主函数在栈中申请空间声明变量p
3. 执行该类中的**static代码块**，如果有的话给Person.class类进行初始化。
4. 在堆内存中开辟空间，分配内存地址。
5. 在堆内存中建立对象的特有属性，并进行**默认初始化**。
6. 对属性进行**显示初始化**
7. 对对象进行**构造代码块初始化**
8. 对对象进行相应的**构造方法初始化**
9. 将堆内存中开辟空间的地址赋给栈内存中的p变量。

[**对象和对象引用的区别**](https://www.iteye.com/blog/zwmf-1738574)

“引用”是啥？是存储对象内存地址的一个变量。
“对象”是啥？堆里new出来的。

**匿名对象**

**定义**

匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。

1. 当对对象的方法**只调用一次**时,可以用匿名对象来完成.

   如果对一个对象的多个成员进行调用,无法使用.

   ```java
   new Student().showStudent();
   ```

2. 可以将匿名对象作为实际参数进行传递.

```java
class Test {
	public static void main(String[] args) {
         // 普通方式
        Scanner sc = new Scanner(System.in);
        input(sc);
         //匿名对象作为方法接收的参数
        input(new Scanner(System.in));
     } 
     public static void input(Scanner sc){
        System.out.println(sc);
     }
 }    
```

#### 封装

  **定义:**隐藏对象的属性和实现细节,仅对外提供公共访问方式

​	 方法就是最小的封装体

#### 继承(extends)

***静态共享的是数据,继承共享的是属性***

**定义：**多个类中存在相同的属性或行为时，将这些内容抽取到单独一个类中，多个类可直接继承这一个类中的属性和行为。

- 提高了代码的复用性
- 让类与类之间产生了关系,提供了多态的前提。
- 不要仅为了获取其他类中某个功能而去继承
- 子类不是父类的子集,而是对父类的**扩展**.

**规则**

- 子类不能直接访问父类中私有的成员变量和方法.

**访问权限**

- 如果子类和父类在同一个包下,那么对于父类的成员修饰符只要不是private,那就都可以用.
- 如果子类和父类不在同一个包下,子类只能使用父类中protected和public修饰的成员

**tip**

- java中只支持单继承，不支持多继承。

- **多继承带来的安全隐患**：

  当多个父类中定义了相同功能，但功能内容不同时，子类对象不确定要运行哪一个。但java保留了这种机制，并用**多实现**来体现

- java支持多层继承，也就是一个继承体系

- 查阅父类功能，创建子类对象使用功能。

**子父类出现后,类成员的特点**:

类中成员:

1. 变量

   子类要访问本类中的变量用this(本类对象引用)

   子类要访问父类中的同名变量,用super.(父类对象引用)

2. 方法

   方法重写(覆盖)

   当子类出现和父类一模一样的方法时,当子类对象调用该方法,会运行子类方法的内容.如同父类的方法被重写一样。

3. 构造方法

   ```简体中文
子类构造方法第一行存在隐式的语句super(),
   super()语句也得放在子类构造方法的第一行,
子类中所有的构造方法第一行默认都有super(),
   子类中至少会有一个构造方法访问父类中的构造方法.
子类中所有的构造器默认都会访问父类中空参数的构造器
   当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行
   如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错
   ```

**this和super的区别**

| **No.** | **区别点** | **this**                                               | **super**                                |
| ------- | ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 1       | 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 访问父类中的属性                         |
| 2       | 调用方法   | 访问本类中的方法                                       | 直接访问父类中的方法                     |
| 3       | 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |
| 4       | 特殊情况   | 表示当前对象                                           | 无此概念                                 |

#### 多态

事物存在的多种体现形态。

**多态的体现**

- 方法的重载(overload)和重写(override).
- 对象的多态性——抽象类和接口
  - Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。
  - 若编译时类型和运行时类型不一致，就出现多态.

```java
//- 父类的引用指向了自己的子类对象
//- 父类的引用也可以接受自己的子类对象	
abstract class Animal {
    abstract void eat();
    abstract void cry();
}
class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
    public void catchMouse() {
        System.out.println("抓老鼠");
    }
    public void cry() {
        System.out.println("喵喵");
    }
}
class DuoTaiDemo {
    public static void main(String[] args) {
        //Cat cat = new Cat();
		Animal animal = new Cat();//类型提升，向上转型
        Cat cat = (Cat)animal;//类型降低，强制转换为子类类型
        cat.catchMouse();
    }
```

**对象类型转换**

java对象的强制类型转换称为造型

- 从子类到父类的类型转换可以自动进行

```java
Animal animal = new Cat();
```

- 从父类到子类的类型转换必须通过造型(强制类型转换)实现

```java
Cat cat = (Cat)animal;
```

- 无继承关系的引用类型间的转换是非法的.

**理解**

- 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(把子类的对象可以给父类的类型的变量引用)

==**多态的应用**==

- 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的==属性==

- 父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的；  同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；  对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接，也可以叫做动态绑定。

  动态绑定是指”在运行期间（而非编译期间）“判断所引用对象的实际类型，根据实际的类型调用其相应的==方法==。

**多态的前提**

1. 必须是类与类之间有关系，要么继承，要么实现。 
2. 存在重写
3. 父类引用指向子类对象

**多态的好处**

​	多态的出现提高了程序的扩展性

**多态的弊端**

​	只能使用父类的引用访问父类中的成员

**多态的应用**

```java
Person e = new Student();
//
Person e:编译时类型
new Student:运行时类型
```

多态中**非静态成员方法**的特点：（成员方法在多态调用时，编译看左边，运行看右边。）

- ​	在编译时期：参阅引用型变量所属的类中是否有调用的方法。如果有编译通过，没有则失败。

- ​	在运行时期：参阅对象所属的类中是否有调用的方法。

多态中**成员变量**的特点：无论编译还是运行，都参考引用型变量所属的类（左边）。

多态中**静态变量**的特点：无论编译还是运行，都参考左边。

##### 抽象类(abstract)

**作用**

抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

**特点:**

1. 抽象方法一定在抽象类中。

2. 抽象方法没有方法体，只有返回类型和方法签名。

3. 抽象方法和抽象类都必须被abstract关键字修饰。

4. 抽象类不可以用new创建对象，因为调用抽象方法没有意义。

5. 抽象类中的方法子类必须全部实现,否则子类也会变为一个抽象类.

6. 抽象类中的抽象方法要被使用，必须由子类重写其所有的抽象方法后，建立子类对象调用

   如果子类只重写了**部分抽象方法**，那么子类还是一个抽象类。

7. **抽象类中不一定全是抽象方法**

8. **抽象类不一定有抽象方法，但是包含一个抽象方法的类一定是抽象类**

**抽象类和一般类的区别**

1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
2. 抽象类不能用来new(创建)对象；
3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

[**抽象类和接口的区别**](http://www.cnblogs.com/dolphin0520/p/3811437.html)

##### 接口

接口的作用是修改父类的功能不会影响到其他子类

抽象方法和常量的定义的集合

可以认为是一个**特殊的抽象类**，接口可以看作是对**类功能的扩展**。

当抽象类中的方法全是抽象的，该类就可以用接口来表示。

==**接口可以被类多实现**==,是对多继承不支持的转换形式。

```java
interface A {
    void methodA();
}
interface B {
    void methodB();
}
interface C  {
    void methodC();
}
class D implements A,B,C {
    public void methodA() {}
    public void methodB() {}
    public void methodC() {}
}
```

**接口与接口之间可以多继承**

```java
interface A {
    void methodA();
}
interface B {
    void methodB();
}
interface C extends B,A {
    void methodC();
}
```

class用于定义类

interface用于定义接口

**接口存在多态**

```java
//Cooking是接口,SCTeacher是实现接口的类.
只能调用接口中存在的方法
Cooking c = new SCTeacher();
		c.fry();
```

**定义接口时的格式特点**：

1. 接口中常见定义：常量，抽象方法。

2. 接口中的成员都有固定修饰符，接口中的成员都是public的。

   ```java
   int NUM =3;//在接口中会自动补齐为标准形式
   public static final int NUM = 3;//在接口中常量的标准形式
   void show();//在接口中会自动补齐为标准形式
   public abstract void show();//在接口中方法的标准形式
   //书写不完整会默认补齐
   ```

**接口的特点：**

- 接口中不能含有静态代码块以及静态方法
- 接口没有构造方法(构造器)
- 接口是对外暴露的规则。
- 接口是程序的功能扩展。
- 接口可以用来多实现。
- 类与接口之间是实现关系，而且类可以**继承一个类的同时实现多个接口**。
- 接口与接口之间可以**多继承**。
- 接口的出现降低了各个需求之间的耦合性（依赖程度）

**Tip**

- 接口不可以创建对象，因为全是抽象方法。
- 接口需要被子类实现，子类对接口中的抽象方法全部重写后，子类才可以实例化。否则子类就是一个抽象类。
- 先继承后实现

##### 抽象类和接口的区别

- 抽象类是对一类事物的高度抽象,其中既有属性也有方法
  - 当需要对一类事物进行抽象时,应使用抽象类形成一个父类

- 接口是对方法的抽象,就是对一系列动作的抽象
  - 当需要对一系列动作进行抽象时,应使用接口,需要使用这些动作时直接去实现相应的接口

#### Object类(根父类)

**概述**

所有对象的直接或者间接父类.

该类中定义的是所有对象都具备的功能.

**应用**

若给某个方法设置一个形参,这个参数当前不确定具体值,但传递进来的实参一定会是个类,那么可以用Object来代替

```java
public void test(Object obj){}
```

| **NO.** | **方法名称**                      | **类型** | **描述**                     |
| ------- | --------------------------------- | -------- | ---------------------------- |
| 1       | public Object()                   | 构造     | 构造方法                     |
| 2       | public boolean equals(Object obj) | 普通     | 对象比较                     |
| 3       | public int hashCode()             | 普通     | 取得Hash码                   |
| 4       | public String toString()          | 普通     | 对象打印时调用(一般必须重写) |

**equals方法与==**

- equals():所有类都继承了Object,也就继承了equals()方法,并可进行重写.**只能比较引用类型**
  - 特殊的:对**File、String、Date及包装类**来说,是**比较类型及其内容**而不考虑引用的是否是同一对象.(因为这些类中都重写了Object类的equals方法)
- ==(判断的是内存地址)比较时,符号两边的数据类型必须兼容(可自动转换的基本数据类型除外),否则无法编译通过

```java
//Object中equals源码(与==无区别都是比较引用数据类型存放的对象的地址值)
public boolean equals(Object obj) {
        return (this == obj);
    }
//String类中重写的equals源码()
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String aString = (String)anObject;
            if (!COMPACT_STRINGS || this.coder == aString.coder) {
                return StringLatin1.equals(value, aString.value);
            }
        }
        return false;
    }
```

#### 泛型类

当类中要操作的引用数据类型不确定的时候.

#### [内部类](https://www.cnblogs.com/dolphin0520/p/3811445.html)

##### 定义

在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

##### 内部类用处

解决java不能多重继承的问题

##### 成员内部类

**定义**

位于另一个类的内部

**特点**:

- **可以**被访问修饰符(public、protected、private)修饰

- **不可以**静态修饰符(static)修饰

- 成员内部类可以**无条件访问**外部类的所有成员属性和成员方法（包括private成员和静态成员）。

- 当成员内部类拥有和外部类**同名的成员变量或者方法**时，会发生**隐藏现象**，即**默认情况**下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：

  - ```java
    外部类.this.成员变量
    外部类.this.成员方法
    ```

- 在外部类中如果要访问成员内部类的成员,必须先创建一个成员内部类的对象,再通过指向这个对象的引用来访问

- 成员内部类是依附外部类而存在的,也就是说,如果要创建成员内部类的对象,前提是必须存在一个外部类的对象。

**代码示例**

```java
class Circle {//外部类
    private double radius = 0;
 
    public Circle(double radius) {
        this.radius = radius;
        getDrawInstance().drawShape();   //必须先创建成员内部类的对象，再进行访问
    }
     
    private Draw getDrawInstance() {
        return new Draw();
    }
     
    class Draw {     //成员内部类
        public void drawShape() {
            System.out.println(radius);  //外部类的private成员
        }
    }
    public static void main(String[] args) {
        //创建内部类对象的方式
        Circle circle =new Circle();
        //第一种创建方式
        Circle.Draw draw =circle.new Draw();
        //第二种创建方式
   		Circle.Draw draw=circle.getDrawInstance();
}
```

##### 局部内部类

**定义**

在**一个方法或者一个作用域**里面的类

**特点**

- **不可以**被访问修饰符(public、protected、private)和静态修饰符(static)修饰

**代码示例**

```java
class People{
    public People() {
         
    }
}
 
class Man{
    public Man(){
         
    }
     
    public People getWoman(){
        class Woman extends People{   //局部内部类
            int age =0;
        }
        return new Woman();
    }
}
```

##### [匿名内部类](https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html)

1. 匿名内部类可以看作是内部类的简写格式。

2. 定义匿名内部类的前提：

   ​	内部类必须是继承一个类或者实现接口。
   
3. 匿名内部类的格式：

   ```java
   // new  父类或者接口（）{定义子类的内容}
   abstract class AbsDemo {
       abstract void show();
   }
   class Outer {
       int x =4;
       public void function() {
           new AbsDemo() {
               void show() {
                   System.out.println("x="+x);
               }
           } .show();
       }
   }
   
   ```

   4.匿名内部类就是一个匿名子类对象。（带内容的对象）

   5.匿名内部类中定义的方法数量不要过多。

##### 静态内部类

**定义**

静态内部类也是定义在另一个类里面的类,只不过在类的前面多了一个关键字static。

**特点**

- 不能使用外部类的非static成员变量或者方法

#### 包

**作用**

- 对类文件进行分类管理
- 给类提供多层命名空间

**包与包之间的访问**

被访问的包中的类以及类中的成员,需要public修饰。

不同包中的子类还可以直接访问父类中被protected权限修饰的成员。

**四种权限**

|          | public | protected | default | private |
| -------- | ------ | --------- | ------- | ------- |
| 同一类中 | √      | √         | √       | √       |
| 同一包中 | √      | √         | √       |         |
| 子类     | √      | √         |         |         |
| 不同包中 | √      |           |         |         |

import关键字导入包

同一个java文件里只能有一个public class剩下的class均为缺省

